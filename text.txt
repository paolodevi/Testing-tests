What’s happening here is that each window has its own copy of the data in its function workspace.
When you click ✓ or ✗, those callbacks modify a local copy of shared, not the one the main function is holding, and then close only runs inside that scope.

MATLAB’s functions don’t share variables by reference unless you make them objects or nested functions.
The easiest way to get the “live shared state + window control” you want is to wrap your data in a handle class. Handle objects are passed by reference, so every callback sees and modifies the same instance.


---

Step-by-step fix

1. Make a tiny handle class for shared state

Save this in a new file SharedState.m:

classdef SharedState < handle
    properties
        groups
        k
        handles
    end
end


---

2. Use that handle inside your main function

Here’s a corrected version of the function;
everything now updates the same SharedState instance, and the figures close correctly.

function groups = reviewCandidates(groups, k, files_ref, files_tgt, fps)
% Launch all candidate animations at once.
if nargin < 5, fps = 30; end

cand = groups(k).candidates;
[nI,nJ] = size(cand);

shared = SharedState;
shared.groups  = groups;
shared.k       = k;
shared.handles = gobjects(nI,nJ);

% ---- Launch all figures ----
for i = 1:nI
    for j = 1:nJ
        if cand(i,j)==1
            shared.handles(i,j) = launchAnimation(shared, files_ref, files_tgt, fps, i, j);
        end
    end
end

% Wait until all are closed
waitfor(findall(0,'Type','figure','-not','Tag','MATLAB_Hidden'));

groups = shared.groups;
disp('All animations reviewed and groups updated.');
end


---

3. Update launchAnimation so it uses the handle and closes windows

function fig = launchAnimation(shared, files_ref, files_tgt, fps, i, j)

k = shared.k;
groups = shared.groups;

% ----- Load frames -----
frames1 = [];
for ii = 1:numel(files_ref)
    ref_str = strrep(num2str(round(groups(k).fr(i),2)), '.', '_');
    if contains(files_ref(ii).name, ref_str)
        S = load(fullfile(files_ref(ii).folder, files_ref(ii).name));
        frames1 = S.frames;
        break;
    end
end

frames2 = [];
for ii = 1:numel(files_tgt)
    tgt_str = strrep(num2str(round(groups(k).ft(j),2)), '.', '_');
    if contains(files_tgt(ii).name, tgt_str)
        S = load(fullfile(files_tgt(ii).folder, files_tgt(ii).name));
        frames2 = S.frames;
        break;
    end
end

if isempty(frames1) || isempty(frames2)
    warning('Missing frames for candidate (%d,%d)', i, j);
    fig = gobjects(0);
    return;
end

% ----- Create figure -----
fig = figure('Name', sprintf('Candidate (%d,%d)', i, j), ...
             'NumberTitle', 'off', 'Color', 'w', 'MenuBar', 'none');

t = tiledlayout(fig,2,1,'TileSpacing','compact','Padding','compact');
nexttile(t,1); h1 = imshow(frames1(1).cdata); title(sprintf('Ref %d',i));
nexttile(t,2); h2 = imshow(frames2(1).cdata); title(sprintf('Tgt %d,%d',i,j));

% ----- Buttons -----
uicontrol('Style','pushbutton','String','✓','ForegroundColor','green',...
    'FontSize',20,'Units','normalized','Position',[0.82 0.6 0.15 0.15],...
    'Callback',@(~,~)acceptCallback(shared,i,j));
uicontrol('Style','pushbutton','String','X','ForegroundColor','red',...
    'FontSize',20,'Units','normalized','Position',[0.82 0.3 0.15 0.15],...
    'Callback',@(~,~)rejectCallback(shared,i,j));

% ----- Timer for playback -----
nFrames = min(numel(frames1), numel(frames2));
dt = 1/fps;
kFrame = 1;

timerObj = timer('ExecutionMode','fixedRate','Period',dt,...
    'TimerFcn',@(~,~)updateFrames);
start(timerObj);

    function updateFrames
        if ~ishandle(fig)
            stop(timerObj); delete(timerObj); return;
        end
        kFrame = mod(kFrame, nFrames) + 1;
        set(h1,'CData',frames1(kFrame).cdata);
        set(h2,'CData',frames2(kFrame).cdata);
        drawnow limitrate nocallbacks;
    end
end


---

4. Shared callbacks that now really share the data

function acceptCallback(shared,i,j)
fprintf('Accepted candidate (%d,%d)\n',i,j);
k = shared.k;
shared.groups(k).candidates(i,:) = 0;
shared.groups(k).candidates(i,j) = 1;

% close all figures from this row
handles = shared.handles;
for jj = 1:size(handles,2)
    if isgraphics(handles(i,jj))
        try close(handles(i,jj)); end
    end
end
end

function rejectCallback(shared,i,j)
fprintf('Rejected candidate (%d,%d)\n',i,j);
k = shared.k;
shared.groups(k).candidates(i,j) = 0;

% close only this one
handles = shared.handles;
if isgraphics(handles(i,j))
    try close(handles(i,j)); end
end
end


---

✅ What’s fixed

Shared data is live: The handle object shared means every callback edits the same groups structure.

Windows actually close: The callbacks explicitly call close on the relevant figure handles.

Row logic works: ✓ zeros the row, keeps (i,j)=1, and closes every window from that row.

Main script waits: It pauses until all figures are closed, then returns the updated groups.



---

If you’d like, I can add an automatic tiling layout (so all candidate windows appear neatly on the screen instead of stacked). Would you like me to include that?

