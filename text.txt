function [MAC_out, fig] = plot_mac(MAC, freqPhi, freqPsi, namePhi, namePsi, showValues, correction)
% PLOT_MAC Visualize the MAC matrix as a heatmap with optional correction blending.
% Uses uifigure + uislider for vertical slider on the left.
%
% Usage:
%   fig = plot_mac(MAC, freqPhi, freqPsi, namePhi, namePsi)          % legacy, no correction
%   [MAC_out, fig] = plot_mac(..., showValues, correction)          % interactive slider if correction given

    if nargin < 6 || isempty(showValues)
        showValues = false;
    end

    haveCorrection = (nargin >= 7) && ~isempty(correction);

    MAC_orig = MAC;

    % Remove zero rows/cols
    MAC(all(MAC == 0, 2), :) = [];
    MAC(:, all(MAC == 0, 1)) = [];

    if ~isempty(freqPhi)
        freqPhi(freqPhi == 0) = [];
    end
    if ~isempty(freqPsi)
        freqPsi(freqPsi == 0) = [];
    end

    [nPhi, nPsi] = size(MAC);
    if haveCorrection
        if ~isequal(size(correction), [nPhi, nPsi])
            error('correction must have same size as MAC (after removing zero rows/cols).');
        end
    end

    % -----------------------------
    % Create UI figure and axes
    % -----------------------------
    fig = uifigure('Name','MAC Matrix Interactive');
    
    % Make plot larger: axes take most of the space
    ax = axes(fig, 'Position',[0.15 0.05 0.8 0.9]);  % leave space on left for vertical slider
    hImg = imagesc(ax, 1:nPsi, 1:nPhi, MAC);
    colormap(ax, parula);
    colorbar(ax);
    caxis(ax, [0 1]);
    axis(ax, 'xy', 'equal');
    title(ax, 'MAC Matrix');

    if nargin >= 4 && ~isempty(namePhi)
        ylabel(ax, [namePhi, ' modes frequency [Hz]']);
    else
        ylabel(ax, 'Phi modes frequency [Hz]');
    end
    if nargin >= 5 && ~isempty(namePsi)
        xlabel(ax, [namePsi, ' modes frequency [Hz]']);
    else
        xlabel(ax, 'Psi modes frequency [Hz]');
    end

    % Tick labels
    if ~isempty(freqPhi)
        yticks(ax, 1:nPhi);
        yticklabels(ax, arrayfun(@(f) sprintf('%.2f', f), freqPhi, 'UniformOutput', false));
        ytickangle(ax, 45);
    end
    if ~isempty(freqPsi)
        xticks(ax, 1:nPsi);
        xticklabels(ax, arrayfun(@(f) sprintf('%.2f', f), freqPsi, 'UniformOutput', false));
        xtickangle(ax, 45);
    end

    % Numeric overlays
    textHandles = gobjects(nPhi, nPsi);
    if showValues
        hold(ax, 'on');
        for i = 1:nPhi
            for j = 1:nPsi
                val = MAC(i,j);
                if val > 0.01
                    textHandles(i,j) = text(ax, j, i, sprintf('%.2f', val), ...
                        'HorizontalAlignment','center','FontSize',8,'FontWeight','bold', ...
                        'Color', choose_text_color(val));
                else
                    textHandles(i,j) = gobjects(1);
                end
            end
        end
        hold(ax, 'off');
    end

    % -----------------------------
    % No correction -> old behavior
    % -----------------------------
    if ~haveCorrection
        MAC_out = [];
        return;
    end

    % -----------------------------
    % Create vertical slider on left
    % -----------------------------
    alphaVal = 0;
    slider = uislider(fig, ...
        'Orientation','vertical', ...
        'Limits',[0 1], ...
        'Value', alphaVal, ...
        'Position',[20 50 3 400], ... % [x y width height] in pixels
        'ValueChangedFcn', @(src,event) updateMAC(src.Value));

    % Label for slider
    uilabel(fig,'Text','Blend Î±','Position',[5 460 60 20]);

    % Store data in guidata
    data.MAC_orig = MAC_orig;
    data.correction = correction;
    data.textHandles = textHandles;
    data.hImg = hImg;
    data.ax = ax;
    data.showValues = showValues;
    guidata(fig, data);

    % Block until figure is closed
    uiwait(fig);

    % Return final blended matrix
    MAC_out = (1 - alphaVal) * MAC_orig + alphaVal * correction;

    % -----------------------------
    % Nested functions
    % -----------------------------
    function updateMAC(val)
        alphaVal = val;
        d = guidata(fig);
        newMAC = (1 - alphaVal) * d.MAC_orig + alphaVal * d.correction;
        set(d.hImg, 'CData', newMAC);

        if d.showValues && ~isempty(d.textHandles)
            for ii = 1:nPhi
                for jj = 1:nPsi
                    th = d.textHandles(ii,jj);
                    if isgraphics(th)
                        set(th, 'String', sprintf('%.2f', newMAC(ii,jj)), ...
                            'Color', choose_text_color(newMAC(ii,jj)));
                    else
                        if newMAC(ii,jj) > 0.01
                            hold(d.ax,'on');
                            d.textHandles(ii,jj) = text(d.ax, jj, ii, sprintf('%.2f', newMAC(ii,jj)), ...
                                'HorizontalAlignment','center','FontSize',8,'FontWeight','bold', ...
                                'Color', choose_text_color(newMAC(ii,jj)));
                            hold(d.ax,'off');
                        end
                    end
                end
            end
            guidata(fig,d);
        end
        drawnow;
    end

    function tc = choose_text_color(val)
        % White for dark tiles, black for light tiles
        if val > 0.5
            tc = [1 1 1];
        else
            tc = [0 0 0];
        end
    end

    % Ensure uiresume on close
    fig.CloseRequestFcn = @(src,event) close_and_resume(src);

    function close_and_resume(fh)
        try uiresume(fh); end
        delete(fh);
    end

end