Perfect — that’s the exact right debugging observation, and you’re 100% correct:
If the figures close properly but groups(k).candidates doesn’t change, it means the callbacks did run, but the edits stayed inside the handle object and never made it back into the variable you see outside the function.

Let’s unpack this carefully and fix it so that the updates persist in your workspace.


---

⚙️ What’s happening

When you run:

groups = reviewCandidates(groups, k, files_ref, files_tgt, fps);

Inside reviewCandidates, we have:

shared.groups = groups;   % copy of your struct into a handle
...
groups = shared.groups;   % copy back out at the end

✅ The callbacks modify shared.groups(k).candidates
❌ But reviewCandidates only returns its own local copy of shared.groups after the figures are closed.

That’s fine — if the function runs to the waitfor(...) and then returns.
However, if your animations close asynchronously (e.g., you press ✓ and figures close but MATLAB hasn’t hit the waitfor yet), it might not capture the updates properly before returning.

So, we’ll fix it to ensure:

1. Updates propagate instantly to the shared handle.


2. When all animations close, we reliably return the final updated groups.


3. reviewCandidates doesn’t exit early.




---

✅ Corrected structure (minimal but robust)

Here’s how to fix this cleanly.

Step 1. Keep using the SharedState handle (same as before)

classdef SharedState < handle
    properties
        groups
        k
        handles
        done = false
    end
end


---

Step 2. Modify reviewCandidates so it waits properly

function groups = reviewCandidates(groups, k, files_ref, files_tgt, fps)
if nargin < 5, fps = 30; end

cand = groups(k).candidates;
[nI,nJ] = size(cand);

shared = SharedState;
shared.groups  = groups;
shared.k       = k;
shared.handles = gobjects(nI,nJ);

% Launch all animations
for i = 1:nI
    for j = 1:nJ
        if cand(i,j)==1
            shared.handles(i,j) = launchAnimation(shared, files_ref, files_tgt, fps, i, j);
        end
    end
end

% Wait until all figures are closed
while any(isgraphics(shared.handles(:)))
    pause(0.2);  % give callbacks time to run
end

% Final update
groups = shared.groups;
end

> 💡 This change ensures we “poll” until all figure handles are closed — not just “waitfor any figure.”




---

Step 3. The callbacks (✓ and ✗) — these are correct already, but let’s double-check

function acceptCallback(shared,i,j)
fprintf('Accepted candidate (%d,%d)\n',i,j);
k = shared.k;
shared.groups(k).candidates(i,:) = 0;
shared.groups(k).candidates(i,j) = 1;

handles = shared.handles;
for jj = 1:size(handles,2)
    if isgraphics(handles(i,jj))
        close(handles(i,jj));
    end
end
end

function rejectCallback(shared,i,j)
fprintf('Rejected candidate (%d,%d)\n',i,j);
k = shared.k;
shared.groups(k).candidates(i,j) = 0;

handles = shared.handles;
if isgraphics(handles(i,j))
    close(handles(i,j));
end
end

Now, since shared.groups is a handle property, every change in these callbacks directly updates the same shared object in memory — and when reviewCandidates finishes (after all figures are closed), it copies that back to your workspace variable.


---

🧪 Quick test (no animation needed)

You can test it without frames:

% Dummy setup
groups(1).candidates = ones(2,3);

% Dummy file lists
files_ref = struct('name',{},'folder',{});
files_tgt = struct('name',{},'folder',{});

% Run
groups = reviewCandidates(groups, 1, files_ref, files_tgt, 2);
disp(groups(1).candidates);

Then press ✓ or ✗ on different windows:

✓ should zero out the row except the chosen candidate.

✗ should zero only that cell.

When all windows are closed, groups(1).candidates should reflect all your choices.



---

Would you like me to add a visual indicator on each figure’s title or border that shows which candidate got accepted/rejected while it’s running? (That’s handy when you have many animations open.)

