Got it üëç ‚Äî you want to reuse your animate_mode_patch_sym function inside a subplot, so that multiple animations (e.g., for different mode shapes or symmetry types) appear side-by-side or in a grid.

Your current function creates its own figure and axes inside, which makes it impossible to embed in subplots as-is.
The fix is simple: we‚Äôll modify the function so it can accept an optional axes handle (ax).
If you don‚Äôt pass one, it will behave exactly like before (open a new figure).
If you do pass one (e.g. a subplot), it will draw the animation there.


---

‚úÖ Step 1 ‚Äî Modify your function

Here‚Äôs the minimal change needed:

function animate_mode_patch_sym(Faces, V0, V1, f, scale, nCycles, nFramesPerCycle, symmetryType, tol, ax)
% animate_mode_patch_sym  Animate eigenmode using patch with correct mirroring
%
% Now supports specifying an external axes handle (for subplots).
%
% Example:
%  ax = subplot(2,2,1);
%  animate_mode_patch_sym(F, V0, V1, f, 5, 3, 100, 'symmetric', 1e-6, ax)

    %% ---- Defaults & validation ----
    if nargin < 11 || isempty(ax)
        animFig = figure('Name', sprintf('Mode %.2f Hz (%s)', f, symmetryType), ...
                         'Color', 'w', 'NumberTitle', 'off');
        ax = axes('Parent', animFig, 'Projection', 'perspective');
    else
        % ensure the axis is valid
        animFig = ancestor(ax, 'figure');
    end

    if nargin < 10, tol = 1e-6; end
    if nargin < 9, symmetryType = 'none'; end
    if nargin < 8, nFramesPerCycle = 100; end
    if nargin < 7, nCycles = 3; end
    if nargin < 6, scale = 5; end

    assert(size(V0,2) == 3, 'V0 must be N√ó3');
    assert(isequal(size(V0), size(V1)), 'V0 and V1 must be same size');

    omega = 2*pi*f;
    tCycle = 1/f;
    t = linspace(0, nCycles*tCycle, nFramesPerCycle*nCycles);

    dV = V1 - V0;
    nNodes = size(V0,1);

    %% ---- Identify nodes to mirror ----
    y = V0(:,2);
    isPlane = abs(y) <= tol;
    isMirror = ~isPlane;

    mapIdx = (1:nNodes)';
    idxMirrorOrig = find(isMirror);
    nMirror = numel(idxMirrorOrig);
    if nMirror > 0
        appendedStart = nNodes + 1;
        appendedIndices = appendedStart + (0:nMirror-1)';
        mapIdx(idxMirrorOrig) = appendedIndices;
    end

    V0_mirrored = V0(idxMirrorOrig, :);
    V0_mirrored(:,2) = -V0_mirrored(:,2);
    dV_mirrored = dV(idxMirrorOrig, :);
    dV_mirrored(:,2) = -dV_mirrored(:,2);
    if strcmpi(symmetryType, 'antisymmetric')
        dV_mirrored = -dV_mirrored;
    end

    V0_combined = [V0; V0_mirrored];
    dV_combined = [dV; dV_mirrored];
    Faces_mirror = mapIdx(Faces);
    Faces_combined = [Faces; Faces_mirror];

    %% ---- Initialize axes and patch ----
    hold(ax, 'on'); grid(ax, 'on'); axis(ax, 'equal');
    xlabel(ax, 'X'); ylabel(ax, 'Y'); zlabel(ax, 'Z');
    title(ax, sprintf('%.2f Hz - %s', f, symmetryType));

    allV = [V0_combined; V0_combined + scale * dV_combined];
    axis(ax, [min(allV(:,1)) max(allV(:,1)) ...
              min(allV(:,2)) max(allV(:,2)) ...
              min(allV(:,3)) max(allV(:,3))]);

    hPatch = patch(ax, ...
        'Faces', Faces_combined, ...
        'Vertices', V0_combined, ...
        'FaceColor', [0.7 0.85 1], ...
        'EdgeColor', 'k', ...
        'FaceLighting', 'gouraud', ...
        'AmbientStrength', 0.3);

    camlight(ax, 'headlight');
    material(ax, 'shiny');
    view(ax, 3);

    %% ---- Animation loop ----
    for i = 1:length(t)
        if ~ishandle(animFig), return; end
        phase = sin(omega * t(i));
        Vnow = V0_combined + scale * dV_combined * phase;
        set(hPatch, 'Vertices', Vnow);
        drawnow limitrate;
    end
end


---

‚úÖ Step 2 ‚Äî Use it with subplots

Now you can do:

figure('Color','w');
ax1 = subplot(2,2,1);
animate_mode_patch_sym(Faces, V0, V1, 50, 5, 3, 100, 'symmetric', 1e-6, ax1);

ax2 = subplot(2,2,2);
animate_mode_patch_sym(Faces, V0, V2, 120, 5, 3, 100, 'antisymmetric', 1e-6, ax2);

ax3 = subplot(2,2,3);
animate_mode_patch_sym(Faces, V0, V3, 200, 5, 3, 100, 'none', 1e-6, ax3);

Each subplot will now show its own independent animation.


---

Would you like me to make the animations synchronized across subplots (so they all move in the same time step per frame)?
That‚Äôs an easy extension, but requires moving the animation loop outside the function.

Perfect üëå ‚Äî to synchronize multiple mode animations across subplots, you need to:

1. Modify your animation function so it only sets up the patch (no time loop).


2. Then, outside the function, run one shared animation loop that updates all patches together per frame.



This way, all modes move in phase ‚Äî great for comparing symmetric vs. antisymmetric modes side-by-side.


---

‚úÖ Step 1 ‚Äî Modify your function to initialize only

We‚Äôll make a new helper version (to keep your original one intact):

function hPatch = setup_mode_patch_sym(Faces, V0, V1, f, scale, symmetryType, tol, ax)
% setup_mode_patch_sym  Prepare a patch for eigenmode visualization (no animation)
%
% Returns:
%   hPatch : handle to patch object (to update later)
%
% Usage:
%   ax = subplot(2,2,1);
%   h1 = setup_mode_patch_sym(Faces, V0, V1, f, 5, 'symmetric', 1e-6, ax);

    if nargin < 7, tol = 1e-6; end
    if nargin < 6, symmetryType = 'none'; end

    assert(size(V0,2) == 3, 'V0 must be N√ó3');
    assert(isequal(size(V0), size(V1)), 'V0 and V1 must be same size');

    dV = V1 - V0;
    nNodes = size(V0,1);

    % Identify which nodes to mirror
    y = V0(:,2);
    isPlane = abs(y) <= tol;
    isMirror = ~isPlane;

    mapIdx = (1:nNodes)';
    idxMirrorOrig = find(isMirror);
    nMirror = numel(idxMirrorOrig);
    if nMirror > 0
        appendedStart = nNodes + 1;
        appendedIndices = appendedStart + (0:nMirror-1)';
        mapIdx(idxMirrorOrig) = appendedIndices;
    end

    % Mirroring
    V0_mirrored = V0(idxMirrorOrig, :);
    V0_mirrored(:,2) = -V0_mirrored(:,2);
    dV_mirrored = dV(idxMirrorOrig, :);
    dV_mirrored(:,2) = -dV_mirrored(:,2);
    if strcmpi(symmetryType, 'antisymmetric')
        dV_mirrored = -dV_mirrored;
    end

    % Combine
    V0_combined = [V0; V0_mirrored];
    dV_combined = [dV; dV_mirrored];
    Faces_mirror = mapIdx(Faces);
    Faces_combined = [Faces; Faces_mirror];

    % Store deformation as UserData for later animation
    hPatch = patch(ax, ...
        'Faces', Faces_combined, ...
        'Vertices', V0_combined, ...
        'FaceColor', [0.7 0.85 1], ...
        'EdgeColor', 'k', ...
        'FaceLighting', 'gouraud', ...
        'AmbientStrength', 0.3, ...
        'UserData', struct('V0', V0_combined, 'dV', dV_combined, 'f', f, 'scale', scale));

    hold(ax, 'on'); grid(ax, 'on'); axis(ax, 'equal');
    xlabel(ax, 'X'); ylabel(ax, 'Y'); zlabel(ax, 'Z');
    title(ax, sprintf('%.2f Hz - %s', f, symmetryType));
    view(ax, 3);
    camlight(ax, 'headlight'); material(ax, 'shiny');
end


---

‚úÖ Step 2 ‚Äî Synchronize animations across subplots

Now you can use that setup function to prepare multiple subplots, then run a single animation loop:

% Example main script

figure('Color','w');

ax1 = subplot(2,2,1);
h1 = setup_mode_patch_sym(Faces, V0, V1, 50, 5, 'symmetric', 1e-6, ax1);

ax2 = subplot(2,2,2);
h2 = setup_mode_patch_sym(Faces, V0, V2, 120, 5, 'antisymmetric', 1e-6, ax2);

ax3 = subplot(2,2,3);
h3 = setup_mode_patch_sym(Faces, V0, V3, 200, 5, 'none', 1e-6, ax3);

patches = [h1, h2, h3];

% ---- Shared time loop ----
nCycles = 3;
nFramesPerCycle = 100;
dt = 1 / nFramesPerCycle;

fMax = max(arrayfun(@(h) h.UserData.f, patches));
tCycle = 1 / fMax;
t = linspace(0, nCycles * tCycle, nCycles * nFramesPerCycle);

for i = 1:length(t)
    for h = patches
        data = h.UserData;
        phase = sin(2*pi*data.f * t(i));
        Vnow = data.V0 + data.scale * data.dV * phase;
        set(h, 'Vertices', Vnow);
    end
    drawnow limitrate;
end


---

‚úÖ Result:

Each subplot shows its own mode shape.

All animations are perfectly synchronized in time.

Each mode oscillates with its own frequency, so higher modes appear to ‚Äúvibrate faster‚Äù.

Works with any number of subplots (just add more calls to setup_mode_patch_sym).



---

Would you like me to extend this so the synchronization is phase-locked (i.e., all cycles complete simultaneously even if frequencies differ)?
That makes it easier for visual comparison, especially if you want them all to start and end aligned.

Excellent idea üí° ‚Äî that‚Äôs a much faster and cleaner approach, especially if you want to later assemble the frames into a GIF or video (or compare them post-process).

You can ‚Äúsimulate‚Äù the animation without rendering it to the screen ‚Äî MATLAB will draw offscreen and you can save each frame as a PNG.

Let‚Äôs modify the synchronized version accordingly.


---

‚úÖ Step 1 ‚Äî Updated approach overview

You‚Äôll:

1. Use the same setup_mode_patch_sym to prepare your patch objects (offscreen or hidden figure).


2. Loop through time steps, update the vertices, and export a PNG per frame.


3. Optionally assemble the PNGs into a GIF or MP4 later.




---

‚úÖ Step 2 ‚Äî The code

function simulate_mode_frames(FacesList, V0List, V1List, freqList, symmetryList, ...
                              scale, nCycles, nFramesPerCycle, outDir)
% simulate_mode_frames
% Simulates synchronized eigenmode animations and saves PNGs (no display).
%
% Inputs:
%  FacesList      - cell array of connectivity matrices
%  V0List, V1List - cell arrays of vertices
%  freqList       - vector of frequencies [Hz]
%  symmetryList   - cell array of symmetry types ('symmetric','antisymmetric','none')
%  scale          - deformation scale
%  nCycles        - number of animation cycles
%  nFramesPerCycle - number of frames per cycle
%  outDir         - output directory for PNGs

    if nargin < 9, outDir = 'frames'; end
    if ~exist(outDir, 'dir'), mkdir(outDir); end

    nModes = numel(freqList);

    % ---- Setup hidden figure and subplots ----
    fig = figure('Visible','off','Color','w','Position',[100 100 1200 800]);

    nRows = ceil(sqrt(nModes));
    nCols = ceil(nModes / nRows);

    hPatches = gobjects(nModes,1);
    for k = 1:nModes
        ax = subplot(nRows, nCols, k, 'Parent', fig);
        hPatches(k) = setup_mode_patch_sym(FacesList{k}, V0List{k}, V1List{k}, ...
                                           freqList(k), scale, symmetryList{k}, 1e-6, ax);
    end

    % ---- Shared animation timing ----
    fMax = max(freqList);
    tCycle = 1 / fMax;
    t = linspace(0, nCycles * tCycle, nFramesPerCycle * nCycles);

    fprintf('Generating %d frames...\n', numel(t));
    for i = 1:numel(t)
        % Update all patches
        for k = 1:nModes
            data = hPatches(k).UserData;
            phase = sin(2*pi*data.f * t(i));
            Vnow = data.V0 + data.scale * data.dV * phase;
            set(hPatches(k), 'Vertices', Vnow);
        end

        % Draw offscreen (but not to screen)
        drawnow limitrate nocallbacks;

        % Save current figure as PNG
        fname = fullfile(outDir, sprintf('frame_%04d.png', i));
        exportgraphics(fig, fname, 'Resolution', 150);
    end

    close(fig);
    fprintf('Frames saved in folder: %s\n', outDir);
end


---

‚úÖ Step 3 ‚Äî Example usage

% Example data setup (you‚Äôll use your real FEM data)
FacesList = {Faces, Faces, Faces};
V0List = {V0, V0, V0};
V1List = {V1, V2, V3};
freqList = [50, 120, 200];
symmetryList = {'symmetric', 'antisymmetric', 'none'};

simulate_mode_frames(FacesList, V0List, V1List, freqList, symmetryList, ...
                     5, 3, 100, 'frames_out');

This will:

Create a hidden figure with 3 synchronized subplots

Simulate each frame offscreen

Save each frame as frames_out/frame_0001.png, frame_0002.png, ‚Ä¶



---

‚úÖ Step 4 ‚Äî (Optional) Combine frames into a GIF or video

Later, you can make a GIF or MP4 easily:

% Create GIF
imds = imageDatastore('frames_out','FileExtensions','.png');
filename = 'modes.gif';
for i = 1:numel(imds.Files)
    [A,map] = rgb2ind(imread(imds.Files{i}),256);
    if i == 1
        imwrite(A,map,filename,'gif','LoopCount',Inf,'DelayTime',0.05);
    else
        imwrite(A,map,filename,'gif','WriteMode','append','DelayTime',0.05);
    end
end

Or for a video:

v = VideoWriter('modes.mp4','MPEG-4');
open(v);
imds = imageDatastore('frames_out','FileExtensions','.png');
for i = 1:numel(imds.Files)
    writeVideo(v, imread(imds.Files{i}));
end
close(v);


---

‚úÖ Performance tips

For fastest performance:

set(fig, 'Visible', 'off');
drawnow limitrate nocallbacks;

Use exportgraphics (high quality, modern) or print (slightly faster, lower quality).

You can parallelize across modes if you generate frames for each mode separately (parfor).



---

Would you like me to modify this script to save one PNG per mode per frame (e.g., mode1_frame_001.png, mode2_frame_001.png, etc.) so you can analyze them separately instead of all in one subplot?

Perfect ‚Äî that‚Äôs actually the most efficient way to do it in MATLAB üëå

Instead of saving PNGs to disk, we can store all frames directly in memory (as a uint8 array) and then write them all at once into a GIF file.
This avoids I/O overhead, keeps it fast, and still lets you generate a high-quality animation.


---

‚úÖ Step-by-step solution

We‚Äôll modify the synchronized simulation so it:

1. Builds each frame offscreen (no display).


2. Captures each frame with getframe or exportgraphics.


3. Stores it in a variable (array or cell array).


4. Writes the whole animation to a .gif.




---

‚úÖ Full MATLAB implementation

function simulate_mode_gif(FacesList, V0List, V1List, freqList, symmetryList, ...
                           scale, nCycles, nFramesPerCycle, gifName)
% simulate_mode_gif
% Simulates synchronized eigenmode animations and saves as a GIF (no display)
%
% Inputs:
%  FacesList      - cell array of connectivity matrices
%  V0List, V1List - cell arrays of vertices
%  freqList       - vector of frequencies [Hz]
%  symmetryList   - cell array of symmetry types ('symmetric','antisymmetric','none')
%  scale          - deformation scale
%  nCycles        - number of animation cycles
%  nFramesPerCycle - frames per cycle
%  gifName        - output GIF filename

    if nargin < 9, gifName = 'modes.gif'; end

    nModes = numel(freqList);
    nRows = ceil(sqrt(nModes));
    nCols = ceil(nModes / nRows);

    fig = figure('Visible', 'off', 'Color', 'w', ...
                 'Position', [100 100 1200 800]);

    % ---- Setup subplots and patches ----
    hPatches = gobjects(nModes,1);
    for k = 1:nModes
        ax = subplot(nRows, nCols, k, 'Parent', fig);
        hPatches(k) = setup_mode_patch_sym(FacesList{k}, V0List{k}, V1List{k}, ...
                                           freqList(k), scale, symmetryList{k}, 1e-6, ax);
    end

    % ---- Shared animation timing ----
    fMax = max(freqList);
    tCycle = 1 / fMax;
    t = linspace(0, nCycles * tCycle, nFramesPerCycle * nCycles);

    % ---- Preallocate frame storage ----
    nFrames = numel(t);
    frames = cell(1, nFrames); % or uint8 array if you want all at once

    fprintf('Generating %d frames in memory...\n', nFrames);

    for i = 1:nFrames
        % Update all mode patches for current frame
        for k = 1:nModes
            data = hPatches(k).UserData;
            phase = sin(2*pi*data.f * t(i));
            Vnow = data.V0 + data.scale * data.dV * phase;
            set(hPatches(k), 'Vertices', Vnow);
        end
        drawnow limitrate nocallbacks;

        % Capture the frame (offscreen)
        frames{i} = getframe(fig);
    end

    % ---- Convert frames to indexed images for GIF ----
    fprintf('Encoding GIF...\n');
    for i = 1:nFrames
        [A,map] = rgb2ind(frame2im(frames{i}), 256);
        if i == 1
            imwrite(A, map, gifName, 'gif', 'LoopCount', Inf, 'DelayTime', 0.05);
        else
            imwrite(A, map, gifName, 'gif', 'WriteMode', 'append', 'DelayTime', 0.05);
        end
    end

    close(fig);
    fprintf('GIF saved: %s\n', gifName);
end


---

‚úÖ Example usage

FacesList = {Faces, Faces, Faces};
V0List = {V0, V0, V0};
V1List = {V1, V2, V3};
freqList = [50, 120, 200];
symmetryList = {'symmetric', 'antisymmetric', 'none'};

simulate_mode_gif(FacesList, V0List, V1List, freqList, symmetryList, ...
                  5, 3, 100, 'modes.gif');

This will:

Generate synchronized animations (no GUI shown)

Store all frames in memory

Save the animation as modes.gif



---

‚úÖ Notes and optimization

getframe(fig) is fast enough for up to a few hundred frames.

To control playback speed, adjust 'DelayTime' (e.g., 0.03 for ~33 FPS).

You can replace getframe(fig) with exportgraphics(fig, 'temp.png') then imread if you prefer precise resolution control.

If you want to export to MP4 instead of GIF, you can directly use:

v = VideoWriter('modes.mp4', 'MPEG-4');
open(v);
for i = 1:nFrames
    writeVideo(v, frame2im(frames{i}));
end
close(v);



---

Would you like me to modify this function to produce both a GIF and an MP4 automatically (since it‚Äôs already generating the frames in memory)?

