% --- User-editable filenames ---
gif1 = 'first.gif';
gif2 = 'second.gif';
outputGif = 'combined_left_halves.gif';

% --- Read infos ---
info1 = imfinfo(gif1);
info2 = imfinfo(gif2);
n1 = numel(info1);
n2 = numel(info2);
n = min(n1, n2); % number of frame pairs to process

% Helper to read a single frame as RGB
readFrameAsRGB = @(file, idx, info) ...
    local_read_frame_rgb(file, idx, info);

% Prepare output: delete existing output if present
if exist(outputGif, 'file')
    delete(outputGif);
end

for k = 1:n
    % Read frames as RGB
    frame1 = readFrameAsRGB(gif1, k, info1);
    frame2 = readFrameAsRGB(gif2, k, info2);

    % Crop left halves
    w1 = size(frame1, 2);
    w2 = size(frame2, 2);
    half1 = floor(w1/2);
    half2 = floor(w2/2);
    left1 = frame1(:, 1:half1, :);
    left2 = frame2(:, 1:half2, :);

    % Match heights: resize the taller one down to the smaller height
    h1 = size(left1, 1);
    h2 = size(left2, 1);
    if h1 ~= h2
        minH = min(h1, h2);
        left1 = imresize(left1, [minH, size(left1,2)]);
        left2 = imresize(left2, [minH, size(left2,2)]);
    end

    % Combine side-by-side
    combined = [left1, left2];

    % Ensure uint8 for rgb2ind conversion
    if ~isa(combined, 'uint8')
        combined_u8 = im2uint8(combined);
    else
        combined_u8 = combined;
    end

    % Convert to indexed + write to GIF
    [ind, map] = rgb2ind(combined_u8, 256);

    % Determine delay time for this combined frame:
    % use max of the two original delays to avoid overly fast frames
    dt1 = info1(k).DelayTime; % seconds
    dt2 = info2(k).DelayTime;
    delay = max(dt1, dt2);

    if k == 1
        imwrite(ind, map, outputGif, 'gif', 'LoopCount', Inf, 'DelayTime', delay);
    else
        imwrite(ind, map, outputGif, 'gif', 'WriteMode', 'append', 'DelayTime', delay);
    end
end

fprintf('Wrote %d frames to %s\n', n, outputGif);

% Play the result
try
    implay(outputGif)
catch
    % fallback: show first frame
    imshow(imread(outputGif, 'Frames', 1));
end

%% --- Local helper function (placed at end of script file) ---
function rgb = local_read_frame_rgb(file, idx, infoStruct)
    % Read frame idx from file and return an MxNx3 double in range [0,1]
    % Handles indexed GIF frames with per-frame colormap and truecolor frames.
    [A, map, alpha] = imread(file, idx); %#ok<ASGLU>
    if ~isempty(map)
        % A is indexed; map is Nx3
        rgb = ind2rgb(A, map); % returns double in 0..1
    else
        % might already be truecolor
        if size(A,3) == 3
            % convert to double normalized
            if isa(A, 'uint8')
                rgb = im2double(A);
            else
                rgb = im2double(uint8(A));
            end
        else
            % single-channel grayscale without colormap -> replicate
            rgb = repmat(im2double(A), [1,1,3]);
        end
    end

    % If alpha exists and you'd like to composite on white background:
    if exist('alpha','var') && ~isempty(alpha)
        % alpha is 0..255 or logical; make logical mask and composite over white
        a = im2double(alpha);
        if isinteger(alpha)
            a = a / double(max(alpha(:)));
        end
        a3 = repmat(a>0, [1,1,3]); % treat nonzero as opaque
        bg = ones(size(rgb)); % white background
        rgb = rgb .* a3 + bg .* (~a3);
    end
end