Perfect â€” thatâ€™s the exact right debugging observation, and youâ€™re 100% correct:
If the figures close properly but groups(k).candidates doesnâ€™t change, it means the callbacks did run, but the edits stayed inside the handle object and never made it back into the variable you see outside the function.

Letâ€™s unpack this carefully and fix it so that the updates persist in your workspace.


---

âš™ï¸ Whatâ€™s happening

When you run:

groups = reviewCandidates(groups, k, files_ref, files_tgt, fps);

Inside reviewCandidates, we have:

shared.groups = groups;   % copy of your struct into a handle
...
groups = shared.groups;   % copy back out at the end

âœ… The callbacks modify shared.groups(k).candidates
âŒ But reviewCandidates only returns its own local copy of shared.groups after the figures are closed.

Thatâ€™s fine â€” if the function runs to the waitfor(...) and then returns.
However, if your animations close asynchronously (e.g., you press âœ“ and figures close but MATLAB hasnâ€™t hit the waitfor yet), it might not capture the updates properly before returning.

So, weâ€™ll fix it to ensure:

1. Updates propagate instantly to the shared handle.


2. When all animations close, we reliably return the final updated groups.


3. reviewCandidates doesnâ€™t exit early.




---

âœ… Corrected structure (minimal but robust)

Hereâ€™s how to fix this cleanly.

Step 1. Keep using the SharedState handle (same as before)

classdef SharedState < handle
    properties
        groups
        k
        handles
        done = false
    end
end


---

Step 2. Modify reviewCandidates so it waits properly

function groups = reviewCandidates(groups, k, files_ref, files_tgt, fps)
if nargin < 5, fps = 30; end

cand = groups(k).candidates;
[nI,nJ] = size(cand);

shared = SharedState;
shared.groups  = groups;
shared.k       = k;
shared.handles = gobjects(nI,nJ);

% Launch all animations
for i = 1:nI
    for j = 1:nJ
        if cand(i,j)==1
            shared.handles(i,j) = launchAnimation(shared, files_ref, files_tgt, fps, i, j);
        end
    end
end

% Wait until all figures are closed
while any(isgraphics(shared.handles(:)))
    pause(0.2);  % give callbacks time to run
end

% Final update
groups = shared.groups;
end

> ğŸ’¡ This change ensures we â€œpollâ€ until all figure handles are closed â€” not just â€œwaitfor any figure.â€




---

Step 3. The callbacks (âœ“ and âœ—) â€” these are correct already, but letâ€™s double-check

function acceptCallback(shared,i,j)
fprintf('Accepted candidate (%d,%d)\n',i,j);
k = shared.k;
shared.groups(k).candidates(i,:) = 0;
shared.groups(k).candidates(i,j) = 1;

handles = shared.handles;
for jj = 1:size(handles,2)
    if isgraphics(handles(i,jj))
        close(handles(i,jj));
    end
end
end

function rejectCallback(shared,i,j)
fprintf('Rejected candidate (%d,%d)\n',i,j);
k = shared.k;
shared.groups(k).candidates(i,j) = 0;

handles = shared.handles;
if isgraphics(handles(i,j))
    close(handles(i,j));
end
end

Now, since shared.groups is a handle property, every change in these callbacks directly updates the same shared object in memory â€” and when reviewCandidates finishes (after all figures are closed), it copies that back to your workspace variable.


---

ğŸ§ª Quick test (no animation needed)

You can test it without frames:

% Dummy setup
groups(1).candidates = ones(2,3);

% Dummy file lists
files_ref = struct('name',{},'folder',{});
files_tgt = struct('name',{},'folder',{});

% Run
groups = reviewCandidates(groups, 1, files_ref, files_tgt, 2);
disp(groups(1).candidates);

Then press âœ“ or âœ— on different windows:

âœ“ should zero out the row except the chosen candidate.

âœ— should zero only that cell.

When all windows are closed, groups(1).candidates should reflect all your choices.



---

Would you like me to add a visual indicator on each figureâ€™s title or border that shows which candidate got accepted/rejected while itâ€™s running? (Thatâ€™s handy when you have many animations open.)

